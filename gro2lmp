#!/usr/bin/perl
use POSIX;

$kj = 96.4853365;



print  "USAGE tinker.xyz ff_directory lmpfile\n";

my @type;
my @atom;
my @x, @y, @z;
my $box_x, $box_y, $box_z;
my $curr_x, $curr_y, $curr_z;


print "I was passed: @ARGV \n";


open(GRO, @ARGV[0]) || die "couldn't open @_[0]\n";
#open(LMPIN, @ARGV[2]) || die "couldn't open @_[2]\n";
open (LMPOUT, ">out.lmp");


if ( !(-d $ARGV[1])) {
	die "Folder does not exsit\n";
}

$line = readline(GRO);
chomp($line);
($throw, $atoms, $name) = split(/\s+/, $line);


print "There are $atoms in $name..apparently";

while($line = readline(GRO)) {
	($throw, $index, $cur_type, $cur_x, $cur_y, $cur_z, $throw, @neigh) = split(/\s+/, $line);
	print "$index is bonded to : @neigh\n";
	if($line =~ /.*[A-Z].*/) {
		push(@type,$cur_type);
		push(@x,$cur_x);
		push(@y,$cur_y);
		push(@z,$cur_z);
		push(@bonds, "@neigh");
	}
	$box_x = $cur_res;
	$box_y = $cur_type;
	$box_z = $i;
}

close(GRO);


# Get Masses from atomtypes.atp

open(FF, "$ARGV[1]/atomtypes.atp") || die "Couldn't open atomtypes.atp\n";
while ($line = readline(FF)) {
	($cur_type, $cur_mass, $throw) = split(/\s+/, $line);
	if(!defined($mass{$cur_type})) {
		$mass{$cur_type} = $cur_mass;
	}
}
close(FF);

print LMPOUT "\nMasses\n\n";
$currtype = 1;
foreach  (@type) {
	if (!defined($typehash{$_})) {
		print LMPOUT "\t$currtype\t$mass{$_}\t#$_\n";
		
		$typehash{$_} = $currtype;
		$currtype ++
	}
}			



open(FF, "$ARGV[1]/ffnonbonded.itp") || die "Couldn't open ffnonbonded.itp\n";
readline(FF);
readline(FF);
while($line = readline(FF)) {
	if (length($line) < 3 ){ last;}
	if ($line =~ /^[^#; ].*/) {
		($cur_type, $cur_at, $cur_mas, $cur_charge, $cur_p, $cur_sigma, $cur_eps, $throw) = split(/\t/, $line);
		print "$line=> $cur_type, $cur_at,$cur_mas,$cur_charge\n";
		$charge{$cur_type} = 0.0;
		chomp($cur_eps);
		$charge{$cur_type} = $cur_charge;
		$sig{$cur_type} = $cur_sigma*10;
		$cur_eps =~ s/ .*//;
		$eps{$cur_type} = $cur_eps/$kj;
	}
	
}



#Move to Pair Types
while ($line = readline(FF)) {
	if($line=~ /.*pairtypes.*/) { readline(FF);last;}
}
$curr_pair = 1;
print LMPOUT "\nPair Coeffs\n\n";
while($line = readline(FF)) {
	if(length($line) < 3){last;}
	if($line =~ /^[^#; ].*/) {
		($atype, $btype, $curtype, $cur_sig, $cur_eps) = split(/\s+/, $line);
		
		if(defined($typehash{$atype}) && ($atype eq $btype)) {
			$epsfudge = sqrt($eps{$atype}*$eps{$btype});
			if ($psfudge==0) {
				print "$atype $eps{$atype} $btype $eps{$btype}\n";
			}
			$sigfudge = 0.5*($sig{$atype}+$sig{$btype});
			print LMPOUT "\t$typehash{$atype}\t$epsfudge\t$sigfudge\t$cur_sig\t$cur_eps # $atype-$btype\n";
			$curr_pair++;
		}
	}
}
foreach  (keys(%typehash)) {
	$epsfudge = sqrt($eps{$_}*$eps{$_});
	$sigfudge = 0.5*($sig{$_}+$sig{$_});
	print LMPOUT "\t$typehash{$_}\t$eps{$_}\t$sig{$_} # \n";
}








open(FF, "$ARGV[1]/ffbonded.itp") || die "Couldn't open $ARGV[1]/ffbonded.itp";
readline(FF);
readline(FF);
#
# Perl hashes are probably not the best way for this. But it'll do.
#

$curr_bond = 1;
print LMPOUT "\nBond Coeffs\n\n";
while ($line = readline(FF)) {
	if(length($line) < 3){last;}
	if($line =~ /^[^#; ].*/) {
		($atype, $btype, $cur_type, $curr_b0, $curr_kb) = split(/\s+/, $line);
		if(!defined($bondtype{"$atype-$btype"})) {
			$bondtype{"$atype-$btype"} = $curr_bond;
			$bondfunc[$curr_bond] = $cur_type;
			$curr_kb = 0.5*0.01*$curr_kb/$kj;
			$curr_b0 *= 10;
			print LMPOUT "\t$curr_bond\t$curr_kb\t$curr_b0\n";
			$curr_bond++;
		}
	}
}

#Move to Angles 
while ($line = readline(FF)) {
	if($line=~ /.*angletypes.*/) { readline(FF);last;}
}
$curr_angle = 1;
print LMPOUT "\nAngle Coeffs\n\n";
while($line = readline(FF)) {
	if(length($line) < 3){last;}
	if($line =~ /^[^#; ].*/) {
		($atype, $btype, $ctype, $cur_type, $th0, $cth, $ub, $cub) = split(/\s+/, $line);
		if(!defined($angletype{"$atype-$btype-$ctype"})) {
			$angletype{"$atype-$btype-$ctype"} = $curr_angle;
			$cth = $cth / $kj;
			$cub = 0.1*$cub/ $kj;
			$ub *= 10;
			print LMPOUT "\t$curr_angle\t$cth\t$th0\t$cub\t$ub # $atype-$btype-$ctype\n";
			$curr_angle++;
		}
	}
}

#Move to Dihedrals
while ($line = readline(FF)) {
	if($line=~ /.*dihedraltypes.*/) { readline(FF);last;}
}
$curr_dihedral = 1;
print LMPOUT "\nDihedral Coeffs\n\n";
while($line = readline(FF)) {
	if(length($line) < 3){last;}
	if($line =~ /^[^#; ].*/) {
		($atype, $btype, $ctype, $dtype, $cur_type, $phi, $cp, $mult) = split(/\s+/,$line);
		if(!defined($dihedtype{"$atype-$btype-$ctype-$dtype"})) {
			if ($cur_type == 9) {
				$phi = floor($phi);
				$phi =~ s/\..*//;
				$cp = $cp/$kj;
				print LMPOUT "\t$curr_dihedral\t$cp\t$mult\t$phi\t0.0 # $atype-$btype-$ctype-$dtype \n";
				$curr_dihedral++;
			}
		}
	}
}

print LMPOUT "\nAtoms\n\n";
for ($i = 0; $i < $atoms; $i++) {
	$j = $i +1;
	print LMPOUT "\t$j\t1\t$typehash{$type[$i]}\t$charge{$type[$i]}\t$x[$i]\t$y[$i]\t$z[$i]\n";
}


print LMPOUT "\nBonds\n\n";
$currbond =1;
for($i = 0; $i < $atoms; $i++) {
	if (length($bonds[$i]) < 1) { 
		next; 
	}
	@neigh = split(/\s+/, $bonds[$i]);
	foreach(@neigh) {
		if ($_ > $i) {
			$j = $i + 1;
			$k = $_ + 1;
			$throw = "$type[$i]-$type[$_]";
			$throw2 = "$type[$_]-$type[$i]";
			if (defined($bondtype{$throw})) {
#			print "$throw = $type[$i] -> $type[$_]\n";
			print LMPOUT "\t$currbond\t$bondtype{$throw}";
			} elsif(defined($bondtype{$throw2})) {
#				print "reversed $throw2 = $type[$_] -> $type[$i]\n";
				print  LMPOUT "\t$currbond\t$bondtype{$throw2}";
			} else {
				# problem type is likely to be the shorter one (and oxygen or carbon or something)
				$probtype = (length($type[$_]) > length($type[$i]))? $type[$i]: $type[$_];
				$goodtype = ($probtype eq $type[$_])? $type[$i]: $type[$_];
				
				$probtype = substr($probtype, 0,1);
				print "Unknown type :(  $type[$_] -> $type[$i]\n";
				print "decided $probtype is likely to be specified incorrectly\n";
				print "and $goodtype is ok\n";
				$matches=0;
				my @match;
				foreach $test_key (keys %bondtype) {
					if($test_key =~ /$goodtype-$probtype.+/) {
						print "$matches $test_key is possible match\n";
						$match[$matches] = $test_key;
						$matches++;
					}
					if($test_key =~ /$probtype.-$goodtype/) {
						print "$matches $test_key is possible match\n";
						$match[$matches] = $test_key;
						$matches++;
					}
				}
				if ($matches > 1) {
					print "Which match would you like?: ";
					chomp($choice = <STDIN>);
					print "Chosen $match[$choice]\n";
				} else { $choice = 0;}
					print LMPOUT "\t$currbond\t$bondtype{$match[$choice]}";
				}
				print LMPOUT "\t$j\t$k # $type[$_] -> $type[$i] \n";
			$currbond++;
		}
	}
}



# Work out angles:
print "\nAngles\n\n";
$angles=1;
for($i = 1; $i <= $atoms; $i++) {
	if (length($bonds[$i-1]) < 3) { 
		next; 
	}
	@neigh = split(/\s+/, $bonds[$i-1]);
	for( $j = 0; $j <scalar @neigh; $j++) {
		for ($k = $j+1; $k < scalar @neigh; $k++) {
			$throw="$type[$neigh[$k]]-$type[$i-1]-$type[$neigh[$j]]";
			$throw2="$type[$neigh[$j]]-$type[$i-1]-$type[$neigh[$k]]";
			if (defined($angletype{$throw}))  {
				print "\t$angles\t$angletype{$throw}\t$neigh[$k]\t$i\t$neigh[$j]\n";
				$angles++;
			} elsif (defined($angletype{$throw2})) {
				print "\t$angles\t$angletype{$throw2}\t$neigh[$j]\t$i\t$neigh[$k]\n";
				$angles++;
			} else {
				print "$throw not found :( \n ";
			}
		}
		
	}
	
	
}





#open(FFNONBONDED, "$ARGV[1]/ffnonbonded.itp") || die "Couldn't open $ARGV[2]/ffnonbonded.itp";

