#!/usr/bin/perl

use POSIX;

my @residues, @atoms, @x, @y, @z, @bonds, @angles, @dihedrals, @cmaps; #System stuff
my %mass, %charge, %sig, %eps, %sig14, %eps14; # force-field stuffs
my %phi, %multi, %cp ,%th, %cth, %cub, %ub, %kb, %b0, %dihF;
my %typeconv, %bondtypes, %angletypes, %dihtypes;
my $box_x, $box_y, $box_z;
my $nAtoms, $nBonds, $nAngles, $nDih;
my $nPt, $nBt, $nDt, $nAt;




sub build_lut{
	local $i, $j,$n, $tmp;
	$n = 1;
	#print keys(%kb);
	foreach (@bonds) {
		($i, $j) = split(/-/, $_);
		$i = $atoms[$i-1];
		$j = $atoms[$j-1];
	#	print "BUILD_LUT: $i-$j\n";
		if (defined($b0{"$i-$j"}) && !defined($bondtypes{"$i-$j"})) {
			$bondtypes{"$i-$j"} = $n;
			$n++;
		} elsif(defined($b0{"$j-$i"}) && !defined($bondtypes{"$j-$i"})) {
			$bondtypes{"$j-$i"} = $n;
			$n++; 
		}
	}
	$nBt = $n-1;
	
	$n = 1; 
	foreach (@angles) {
		($i, $j,$k) = split(/-/, $_);
		$i = $atoms[$i-1];
		$j = $atoms[$j-1];
		$k = $atoms[$k-1];
		if (defined($ub{"$i-$j-$k"}) && !defined($angletypes{"$i-$j-$k"})) {
			$angletypes{"$i-$j-$k"} = $n;
			$n++;
		} elsif (defined($ub{"$k-$j-$i"}) && !defined($angletypes{"$k-$j-$i"})) {
			$angletypes{"$k-$j-$i"} = $n;
			$n++;
		}
		
	}
	$nAt = $n-1;
	
	$n = 1; 
	foreach (@dihedrals) {
		($i, $j,$k,$l) = split(/-/, $_);
		$i = $atoms[$i-1];
		$j = $atoms[$j-1];
		$k = $atoms[$k-1];
		$l = $atoms[$l-1];
		if (defined($phi{"$i-$j-$k-$l"}) && !defined($dihtypes{"$i-$j-$k-$l"})) {
			$dihtypes{"$i-$j-$k-$l"} = $n;
			$n++;
		} elsif (defined($phi{"$l-$k-$j-$i"}) && !defined($dihtypes{"$l-$k-$j-$i"})) {
			$dihtypes{"$l-$k-$j-$i"} = $n;
			$n++;
		} elsif(defined($phi{"X-$j-$k-X"}) && !defined($dihtypes{"X-$j-$k-X"})) {
			$dihtypes{"X-$j-$k-X"} = $n;
			$n++;
		}elsif(defined($phi{"X-$k-$j-X"}) && !defined($dihtypes{"X-$k-$j-X"})) {
			$dihtypes{"X-$k-$j-X"} = $n;
			$n++;
		}
		
	}
	$nDt = $n-1;
	
			
	
}






sub parse_gro  {
	local $i, $j,$tmp;
	local $line;
	local $cur_res, $cur_type, $cur_x, $cur_y, $cur_z;
	open(GRO, "$ARGV[1]") || die "couldn't open $ARGV[1]\n";
	$line = readline(GRO);
	$nAtoms = readline(GRO);
	$nAtoms =~ s/\s+//g;
	$j =1;
	chomp($nAtoms);
	for ( $i = 0; $i < $nAtoms; $i++) {
		$line = readline(GRO);
		($tmp,$cur_res, $cur_type, $j, $cur_x, $cur_y, $cur_z) = split(/\s+/, $line);	
		push(@x,$cur_x);
		push(@y,$cur_y);
		push(@z,$cur_z);
		push(@residues, $cur_res);
		
	}
	$line = readline(GRO);
	($tmp,$box_x, $box_y, $box_z)  = split(/\s+/, $line);
	
	close(GRO);
}

sub parse_atoms {
	local $i,$tmp;
	local $cur_res, $cur_type, $cur_resnr, $cur_restype, $cur_cgnr, $cur_charge, $cur_mass;
	
	open(TOP, "$ARGV[2]") || die "couldn't open $ARGV[1]\n";
	#Go to atoms section;
	while ($line = readline(TOP)) {
		if ($line =~ /.*atoms.*/) {
			last;
		}
	}
	$j = 1;
	while ($line = readline(TOP)) {
		if ($line =~ /^[;]/) { next;} # Skip anything commented out.
		if (length($line) < 3) { last ;}  # Don't carry on after a blank line.
		$line =~ s/;.*//; # Throw any trailing comments away
		
		($tmp, $i, $cur_type, $cur_resnr, $cur_restype, $tmp,$cur_cgnr, $cur_charge, $cur_mass) = split(/\s+/, $line);
		
		push(@atoms,$cur_type);
		if (!defined($typeconv{$cur_type})) {
			$typeconv{$cur_type} = $j;
			$j++;
		}
		
		# Only things were really interested in is charge and mass;
		$mass{$cur_type} = $cur_mass;
		$charge{$cur_type} = $cur_charge;
	}
	close(TOP);
}

sub parse_bonds {
	local $i, $j, $tmp, $func;
	$nBonds = 0;
	open(TOP, "$ARGV[2]") || die "couldn't open $ARGV[2] for bond parsing";
	while ($line = readline(TOP)) {
		if ($line =~ /.*bonds.*/) {
			last;
		}
	}
	while ($line = readline(TOP)) {
		if ($line =~ /^;/) { next;} # Skip anything commented out.
		if (length($line) < 3) { last ;}  # Don't carry on after a blank line.
		$line =~ s/;.*//; # Throw any trailing comments away
		($tmp, $i, $j,$func) = split(/\s+/, $line);
		push(@bonds, "$i-$j");
		$nBonds++;
	}
	close(TOP);
}
		
sub parse_angles {
	local $i, $j, $k,$tmp, $func;
	open(TOP, "$ARGV[2]") || die "couldn't open $ARGV[2] for angle parsing";
	while ($line = readline(TOP)) {
		if ($line =~ /.*angles.*/) {
			last;
		}
	}
	$nAngles =0;
	while ($line = readline(TOP)) {
		if ($line =~ /^;/) { next;} # Skip anything commented out.
		if (length($line) < 3) { last ;}  # Don't carry on after a blank line.
		$line =~ s/;.*//; # Throw any trailing comments away
		($tmp, $i, $j,$k,$func) = split(/\s+/, $line);
		push(@angles, "$i-$j-$k");
		$nAngles ++;
	}
	close(TOP);
}

sub parse_dih {
	local $i, $j, $k,$l,$tmp, $func;
	open(TOP, "$ARGV[2]") || die "couldn't open $ARGV[2] for angle parsing";
	while ($line = readline(TOP)) {
		if ($line =~ /.*dihedrals.*/) {
			last;
		}
	}
	$nDih =0;
	while ($line = readline(TOP)) {
		
		if ($line =~ /^;/) { next;} # Skip anything commented out.
		if (length($line) < 3) { last ;}  # Don't carry on after a blank line.
		$line =~ s/;.*//; # Throw any trailing comments away
		($tmp, $i, $j,$k,$l,$func) = split(/\s+/, $line);
		
		push(@dihedrals, "$i-$j-$k-$l");
		$nDih ++;
	}
	close(TOP);
}

sub parse_cmap {
	local $i, $j, $k,$l,$m,$tmp, $func;
	open(TOP, "$ARGV[2]") || die "couldn't open $ARGV[2] for angle parsing";
	while ($line = readline(TOP)) {
		if ($line =~ /.*dihedrals.*/) {
			last;
		}
	}
	$nCMAP =0;
	while ($line = readline(TOP)) {
		if ($line =~ /^[;]/) { next;} # Skip anything commented out.
		if (length($line) < 3) { last ;}  # Don't carry on after a blank line.
		$line =~ s/;.*//; # Throw any trailing comments away
		($tmp, $i, $j,$k,$l,$m,$func) = split(/\s+/, $line);
		push(@cmaps, "$i-$j-$k-$l-$m");
		$nCMAP ++;
	}
	close(TOP);
}	


sub parse_nonb {
	open(FF, "$ARGV[3]/ffnonbonded.itp") || die "Couldn't open $ARGV[3]ffnonbonded.itp\n";
	readline(FF);
	readline(FF);
	while($line = readline(FF)) {
		if (length($line) < 3 ){ last;}
		if ($line =~ /^[^#; ].*/) {
			($cur_type, $cur_at, $cur_mas, $cur_charge, $cur_p, $cur_sigma, $cur_eps, $throw) = split(/\t/, $line);
			chomp($cur_eps);
			$sig{$cur_type} = $cur_sigma;
			$cur_eps =~ s/ .*//;
			$eps{$cur_type} = $cur_eps;
		}
		
	}
	
	while ($line = readline(FF)) {
		if($line=~ /.*pairtypes.*/) { readline(FF);last;}
	}
	$nPt = 1;
	while($line = readline(FF)) {
		if(length($line) < 3){last;}
		if($line =~ /^[^#; ].*/) {
			($atype, $btype, $curtype, $cur_sig, $cur_eps) = split(/\s+/, $line);
			$sig14{"$atype-$btype"} = $cur_sig;
			$eps14{"$atype-$btype"} = $cur_eps;
			$nPt++;
		}
	}
	close(FF);
}

sub parse_bonded {
	open(FF, "$ARGV[3]/ffbonded.itp") || die "Couldn't open ffbonded.itp\n";
	readline(FF);
	readline(FF);
	#
	# Perl hashes are probably not the best way for this. But it'll do.
	#
	$nBt = 1;
	while ($line = readline(FF)) {
		if(length($line) < 3){last;}
		if($line =~ /^[^#; ].*/) {
			($atype, $btype, $cur_type, $curr_b0, $curr_kb) = split(/\s+/, $line);
			if(!defined($bondtype{"$atype-$btype"})) {
				$bondtype{"$atype-$btype"} = $curr_bond;
				$bondfunc[$curr_bond] = $cur_type;
				$b0{"$atype-$btype"} = $curr_b0;
				$kb{"$atype-$btype"} = $curr_kb;
				$nBt++;
			}
		}
	}
	
	#Move to Angles 
	while ($line = readline(FF)) {
		if($line=~ /.*angletypes.*/) { readline(FF);last;}
	}
	$nAt = 1;
		while($line = readline(FF)) {
		if(length($line) < 3){last;}
		if($line =~ /^[^#; ].*/) {
			($atype, $btype, $ctype, $cur_type, $cur_th0, $cur_cth, $cur_ub, $cur_cub) = split(/\s+/, $line);
			$th{"$atype-$btype-$ctype"} = $cur_th0;
			$cth{"$atype-$btype-$ctype"} = $cur_cth;
			$cub{"$atype-$btype-$ctype"} = $cur_cub;
			$ub{"$atype-$btype-$ctype"}= $cur_ub;
			$nAt++;
		}
	}
	
	#Move to Dihedrals
	while ($line = readline(FF)) {
		if($line=~ /.*dihedraltypes.*/) { readline(FF);last;}
	}
	$nDt = 1;
	while($line = readline(FF)) {
		if(length($line) < 3){last;}
		if($line =~ /^[^#; ].*/) {
			($atype, $btype, $ctype, $dtype, $cur_type, $cur_phi, $cur_cp, $cur_mult) = split(/\s+/,$line);
			if ($cur_type == 9) {
				$tmp = "$atype-$btype-$ctype-$dtype";
				$cur_phi = floor($cur_phi);
				$cur_phi =~ s/\..*//;
				$phi{$tmp} = $cur_phi;
				$cp{$tmp} =  $cur_cp;
				$multi{$tmp} = $cur_mult;
				$nDt++;
				
			}
		}
	}
}

sub to_types {
	local @i,$tmp;
	$line = @_[0];
	@i = split(/-/, $line);
	$line="";
	foreach $tmp (@i) {
		#print "$tmp\n";
		$line = "$line-$atoms[$tmp-1]";
	}
	$line =~ s/^-//;
	#print "TO_TYPES: $line from @_[0]\n";
	
	return($line);
}

sub conversion {
	local $kj = 96.4853365;
	#Convert all units - :(
	
	#b0 nm -> A
	foreach (keys(%b0)) {
		$b0{$_} *= 10;
	}
	#kb Kj/mol nm^-2 ev/A^2
	foreach (keys(%kb)) {
		$kb{$_} = $kb{$_}/$kj*0.01;
	}
	
	#cth Kj/mol -> eV
	foreach (keys(%cth)) {
		$cth{$_} /= $kj;
	}
	
	#cub Kj/Mol /nm -> eV/A
	foreach (keys(%cub)) {
		$cub{$_} *= 0.1/$kj;
	}
	
	#ub nm -> A
	foreach (keys(%ub)) {
		$ub{$_} *= 0.1/$kj;
	}
	
	#sig Kj/mol -> eV
	foreach (keys(%sig)) {
		$sig{$_} /= $kj;
	}
	
	#eps nm -> A
	foreach (keys(%eps)) {
		$eps{$_} *= 10;
	}
	
	# Positions nm -> A
	for ($i =0; $i < $nAtoms; $i ++) {
		$x[$i] *= 10;
		$y[$i] *= 10;
		$z[$i] *= 10;
	}
	
	$box_x *= 10;
	$box_y *= 10;
	$box_z *= 10;

}




parse_gro();

parse_atoms();
parse_angles();

parse_bonds();
parse_cmap();
parse_dih();


parse_nonb();
parse_bonded();

build_lut();
conversion();


#Output stage

print "LAMMPS description\n";
print "\n";
print "$nAtoms atoms\n";
print "$nBonds bonds\n";
print "$nAngles angles\n";
print "$nDih dihedrals\n";
$i = scalar keys(%mass);
print "$i atom types\n";
print "$nDt dihedral types\n";
print "$nAt angle types\n";
print "$nBt bond types\n";


print "\n";
print "0 $box_x xlo xhi\n";
print "0 $box_y ylo yhi\n";
print "0 $box_z zlo zhi\n";

print "\n";

print "Masses\n\n";
$i = 1;
foreach (keys(%mass)) {
	print "\t$i\t$mass{$_}\t# $_\n";
	$i++;
}
print "\nPair Coeffs\n\n";
$i = 1;
foreach $_ (keys(%mass)) {
	print  "\t$i\t$eps{$_}\t$sig{$_}\n";
	$i++
}

print "\n\nBond Coeffs\n\n";
foreach $_ (keys(%bondtypes)) {
	print "\t$bondtypes{$_}\t$kb{$_}\t$b0{$_}\n";
}

print "\nAngle Coeffs\n\n";
foreach $_ (keys(%angletypes)) {
	print "\t$angletypes{$_}\t$th{$_}\t$cth{$_}\t$cub{$_}\t$ub{$_}\n";
}

print "\nDihedral Coeffs\n\n";
foreach $_ (keys(%dihtypes)) {
	print "\t$dihtypes{$_}\t$cp{$_}\t$multi{$_}\t$phi{$_}\t1.0\n";
}


print "\nAtoms\n\n";

for($i =1; $i<=$nAtoms; $i++) {
	print "\t$i\t1\t$typeconv{$atoms[$i-1]}\t$charge{$atoms[$i-1]}\t$x[$i-1]\t$y[$i-1]\t$z[$i-1]# $atoms[$i-1]\n";
}
print "\nBonds\n\n";
$k=1;

foreach $_ (@bonds) {
	($i, $j) = split(/-/, $_);
	$tmp = (defined($bondtypes{to_types($_)}))? $bondtypes{to_types($_)}: $bondtypes{to_types("$j-$i")};
	print "\t$k\t$tmp\t$i\t$j\n";
	$k++;
}

print "\nAngles\n\n";
$l=1;

foreach $_ (@angles) {
	($i, $j,$k) = split(/-/, $_);
	$tmp = (defined($angletypes{to_types($_)}))? $angletypes{to_types($_)}: $angletypes{to_types("$k-$j-$i")};
	print "\t$l\t$tmp\t$i\t$j\t$k\n";
	$l++;
}

print "\nDihedrals\n\n";
$h = 1;
foreach $_ (@dihedrals) {
	($i, $j, $k,$l) = split(/-/,$_);
	$tmp = (defined($dihtypes{to_types($_)}))? $dihtypes{to_types($_)}: $dihtypes{to_types("$l-$k-$j-$i")};
	if ($tmp eq "") {
		$tmp = (defined($dihtypes{to_types("X-$j-$k-X")}))? $dihtypes{to_types("X-$j-$k-X")}: $dihtypes{to_types("X-$k-$j-X")};
	}
	print "\t$h\t$tmp\t$i\t$j\t$k\t$l\n";
	$h++;
}



